@model Booking
@{
    ViewData["Title"] = "Erstellen";
}

<h1 class="page-title">@ViewData["Title"]</h1>

<!-- Form Tag Helper in order to prevent cross-site request forgery -->
<form asp-controller="Booking" asp-action="Create" method="post">
    <div class="form-group row">
        <label for="Charge" class="col-2 col-form-label">Current state of charge:</label>
        <input name="Charge" class="col-10 form-control" asp-for="Charge"><br />
        <span asp-validation-for="Charge" class="text-danger form-danger-span"></span>
    </div>
    <div class="form-group row">
        <label for="Needed_distance" class="col-2 col-form-label">Needed Distance:</label>
        <input name="Needed_distance" class="col-10 form-control" asp-for="Needed_distance"><br />
        <span asp-validation-for="Needed_distance" class="text-danger form-danger-span"></span>
    </div>
    <div class="form-group row">
        <label for="Start_time" class="col-2 col-form-label">Start time:</label>
        <input id="Start_time" name="Start_time" class="col-10 form-control" asp-for="Start_time"><br />
        <span asp-validation-for="Start_time" class="text-danger form-danger-span"></span>
    </div>
    <div class="form-group row">
        <label for="End_time" class="col-2 col-form-label">End time:</label>
        <input id="End_time" name="End_time" class="col-10 form-control" onchange="validate_Date()" asp-for="End_time"><br />
        <span asp-validation-for="End_time" class="text-danger form-danger-span"></span>
        <a class="text-danger form-danger-span" id="error_panel" name="error_panel"></a>
    </div>
    <div class="form-group row">
        <label for="s_type" class="col-2 col-form-label">Steckertype:</label>
        <select class="col-10 form-control" asp-for="s_type" asp-items="Html.GetEnumSelectList<Booking.Steckertyp>()"></select><br />
        <span asp-validation-for="s_type" class="text-danger form-danger-span"></span>
    </div>
    <div class="row">
        <button id="btnsub" name="btnsub" class="btn btn-success col-12" type="submit">Erstellen</button>
    </div>
</form>


<!-- Enable client side validation -->
@section Scripts {
    @{await Html.RenderPartialAsync("_ValidationScriptsPartial"); }
}

<script>function validate_Date() {
        let start_time = document.getElementById('Start_time');
        let end_time = document.getElementById('End_time');
        let sub_button = document.getElementById('btnsub');
        if (start_time.value >= end_time.value) {
            print_err("End before start!!");
            sub_button.disabled = true;
        } else {
            sub_button.disabled = false;
            print_err("");
        }
    }
    function print_err(Error_Message) {
        let importFormSpawn = $('#error_panel');
        importFormSpawn.text(Error_Message);
    }</script>





<!-- Questions and answers of the assignment -->
<div class="QA" style="margin-top: 2em;">
    <p>
        <b>Was ist Cross-site request forgery und wie lässt es sich in ASP.Net Core unterbinden?</b> <br />
        Eine Cross-site-Request-Forgery ist ein Computerangriff, bei dem man das einem bekannte Format eines Post Requests auf eine fremde Seite ausnutzt,
        indem man z.B. während jemand in einem Tab bei seinem Online Banking Account angemeldet ist, in einem anderen Tab eben genau den Post Request zu der Bank sendet,
        der auch gesendet werden würde, wenn man das eigentliche Formular auf der originalen Seite verwendet. Da der Nutzer bereits dort angemeldet ist, könnte man so theoretisch
        unbemerkt Geld an sich selbst senden.<br />
        Indem man in ASP.Net Core den Form Tag Helper anstatt eines normalen Form Tags verwendet und bei der entsprechenden Post Action die Token Validierung aktiviert,
        kann man dieses Problem umgehen. Dadurch wird jedes Mal, wenn die Seite bei einem Client geladen wird, ein eindeutiger Schlüssen erstellt, welcher dann beim Server gespeichert,
        im besten Fall mit einem Account assoziiertund der Form beigefügt wird. Post Requests müssen dann einen gültigen Schlüssel aufweisen, da diese sonst ignoriert werden.
    </p>
    <p>
        <b>Was ist der wesentliche Unterschied zwischen GET und POST Anfragen? Gibt es weitere Anfragetypen?</b> <br />
        Bei GET Requests werden die Parameter über die URL mitgeteilt, während sie bei einem POST Request über den Message Body gesendet werden.<br />
        Weitere Anfragetypen sind: PUT, HEAD, DELETE, PATCH, OPTIONS, TRACE, CONNECT.
    </p>
    <p>
        <b>Wie lange ist ein Objekt im Cache verfügbar?</b><br />
        Bis die Anwendung beim Server beendet wird, der Speicherplatz nicht überfüllt ist oder falls angegeben die maximale Zeit überschritten wurde.
    </p>
    <p>
        <b>Was ist der wesentliche Unterschied zwischen dem Cache und einer Datenbank?</b><br />
        Die Datenbank ist anders als der Cache persistent, würde also auch einen kompletten Systemabsturz überleben, da diese tatsächlich auf der Festplatte gespeichert wird.
    </p>
    <p>
        <b>Ist der Cache Nutzerspezifisch oder Apllikationsweit? Falls letzteres zutrifft: Worauf sollte geachtet werden?</b><br />
        Der Cache ist Applikationsweit. Falls also Nutzerspezifische Daten gespeichert werden, sollten diese nur mit einem eindeutigen, persönlichen und geheimen Schlüssel referenziert werden können.
    </p>
    <p>
        <b>Was ist Dependency Injection?</b><br />
        Depenendy Injejtion ist eine Technik zum Trennen der Erstellung von von Dependencies von der Klasse in der sie benutzt werden.
        Anstatt die nötigen Objekte der Abhängigkeit selbst zu erstellen, soll die eigene Klasse nur eine Schnittstelle definieren, über die bereits fertige Objekte übergeben werden,
        die diese Schnittstelle implementieren. So lassen sich die Objekte von denen die eigene Klasse abhängig ist sogar noch während der Laufzeit austauschen.
        Die vermittlung zwischen der eigenen Klasse und den Abhängigkeiten übernimmt dann eben die Dependency Injection, anstatt dass diese Aufgabe in eine der beiden Klassen integriert wird.
    </p>
    <p>
        <b>Warum ist eine beidseitige Validierung eine gute Idee?</b><br />
        Die clientseitige Validerung ist gut um dem Nutzer ein Feedback zu geben, welche der Daten z.B. nicht stimmen oder fehlen.<br />
        Die serverseitige Validierung ist z.B. gut um zu verhindern, dass willentlich korrupte Daten eingefügt werden.
    </p>
</div>
